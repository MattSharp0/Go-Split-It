// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: views.sql

package db

import (
	"context"

	"github.com/shopspring/decimal"
)

const groupBalances = `-- name: GroupBalances :many
SELECT 
    c.user_id as creditor_id, 
    c.member_name as creditor, 
    d.user_id as debtor_id,
    d.member_name as debtor,
    gb.total_owed::numeric(10,2) as total_owed -- sum returns unconstrained numeric
FROM group_balances gb
JOIN group_members c on c.id = gb.creditor
JOIN group_members d on d.id = gb.debtor
WHERE gb.group_id = $1
ORDER BY c.member_name, d.member_name
`

type GroupBalancesRow struct {
	CreditorID *int64          `json:"creditor_id"`
	Creditor   *string         `json:"creditor"`
	DebtorID   *int64          `json:"debtor_id"`
	Debtor     *string         `json:"debtor"`
	TotalOwed  decimal.Decimal `json:"total_owed"`
}

func (q *Queries) GroupBalances(ctx context.Context, groupID int64) ([]GroupBalancesRow, error) {
	rows, err := q.db.Query(ctx, groupBalances, groupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GroupBalancesRow{}
	for rows.Next() {
		var i GroupBalancesRow
		if err := rows.Scan(
			&i.CreditorID,
			&i.Creditor,
			&i.DebtorID,
			&i.Debtor,
			&i.TotalOwed,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const groupBalancesNet = `-- name: GroupBalancesNet :many
SELECT
    gm.user_id as user_id,
    gm.member_name as user_name,
    gbn.net_balance::numeric(10,2) as net_balance -- sum returns unconstrained numeric
FROM group_balances_net gbn
JOIN group_members gm on gm.id = gbn.user_id
WHERE gbn.group_id = $1
ORDER BY gm.member_name
`

type GroupBalancesNetRow struct {
	UserID     *int64          `json:"user_id"`
	UserName   *string         `json:"user_name"`
	NetBalance decimal.Decimal `json:"net_balance"`
}

func (q *Queries) GroupBalancesNet(ctx context.Context, groupID int64) ([]GroupBalancesNetRow, error) {
	rows, err := q.db.Query(ctx, groupBalancesNet, groupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GroupBalancesNetRow{}
	for rows.Next() {
		var i GroupBalancesNetRow
		if err := rows.Scan(&i.UserID, &i.UserName, &i.NetBalance); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const userBalancesByGroup = `-- name: UserBalancesByGroup :many
SELECT
    g.id as group_id,
    g.name as group_name,
    gbn.net_balance::numeric(10,2) as net_balance
FROM group_balances_net gbn
JOIN group_members gm on gm.id = gbn.user_id
JOIN groups g on g.id = gbn.group_id
WHERE gm.user_id = $1
ORDER BY g.name
`

type UserBalancesByGroupRow struct {
	GroupID    int64           `json:"group_id"`
	GroupName  string          `json:"group_name"`
	NetBalance decimal.Decimal `json:"net_balance"`
}

// Returns balances by group for a specific user
// Only includes groups where the user is a member (filtered via WHERE gm.user_id = $1)
// This is the correct place to filter by user membership for security and performance
func (q *Queries) UserBalancesByGroup(ctx context.Context, userID *int64) ([]UserBalancesByGroupRow, error) {
	rows, err := q.db.Query(ctx, userBalancesByGroup, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []UserBalancesByGroupRow{}
	for rows.Next() {
		var i UserBalancesByGroupRow
		if err := rows.Scan(&i.GroupID, &i.GroupName, &i.NetBalance); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const userBalancesByMember = `-- name: UserBalancesByMember :many
SELECT
    ubm.member_user_id as member_user_id,
    u.name as member_name,
    ubm.net_balance::numeric(10,2) as net_balance
FROM user_balances_by_member ubm
JOIN users u on u.id = ubm.member_user_id
WHERE ubm.user_id = $1
ORDER BY u.name
`

type UserBalancesByMemberRow struct {
	MemberUserID *int64          `json:"member_user_id"`
	MemberName   string          `json:"member_name"`
	NetBalance   decimal.Decimal `json:"net_balance"`
}

func (q *Queries) UserBalancesByMember(ctx context.Context, userID *int64) ([]UserBalancesByMemberRow, error) {
	rows, err := q.db.Query(ctx, userBalancesByMember, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []UserBalancesByMemberRow{}
	for rows.Next() {
		var i UserBalancesByMemberRow
		if err := rows.Scan(&i.MemberUserID, &i.MemberName, &i.NetBalance); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const userBalancesSummary = `-- name: UserBalancesSummary :one
SELECT
    (SELECT 
        COALESCE(SUM(ubn.net_balance), 0)::numeric(10,2)
        FROM user_balances_net ubn 
        WHERE ubn.user_id = $1) as net_balance,
    (SELECT 
        COALESCE(SUM(CASE WHEN ubm.net_balance < 0 THEN -ubm.net_balance ELSE 0 END), 0)::numeric(10,2)
     FROM user_balances_by_member ubm 
     WHERE ubm.user_id = $1) as total_owed,
    (SELECT 
        COALESCE(SUM(CASE WHEN ubm.net_balance > 0 THEN ubm.net_balance ELSE 0 END), 0)::numeric(10,2)
     FROM user_balances_by_member ubm 
     WHERE ubm.user_id = $1) as total_owed_to_user
`

type UserBalancesSummaryRow struct {
	NetBalance      decimal.Decimal `json:"net_balance"`
	TotalOwed       decimal.Decimal `json:"total_owed"`
	TotalOwedToUser decimal.Decimal `json:"total_owed_to_user"`
}

func (q *Queries) UserBalancesSummary(ctx context.Context, userID *int64) (UserBalancesSummaryRow, error) {
	row := q.db.QueryRow(ctx, userBalancesSummary, userID)
	var i UserBalancesSummaryRow
	err := row.Scan(&i.NetBalance, &i.TotalOwed, &i.TotalOwedToUser)
	return i, err
}
