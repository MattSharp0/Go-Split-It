// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: split.sql

package db

import (
	"context"

	"github.com/shopspring/decimal"
)

const createSplit = `-- name: CreateSplit :one
/*
split queries
Table structure:
id bigserial PRIMARY KEY,
transaction_id bigint NOT NULL,
tx_amount numeric(10,2) NOT NULL,
split_percent decimal(5,4) NOT NULL,
split_amount numeric(10,2) NOT NULL,
split_user bigint,
created_at timestamptz NOT NULL DEFAULT (now()),
modified_at timestamptz NOT NULL DEFAULT (now())

*/

INSERT INTO "splits" (transaction_id, tx_amount, split_percent, split_amount, split_user) 
VALUES ($1, (SELECT amount from transactions where id = $1), $2, $3, $4) 
RETURNING id, transaction_id, tx_amount, split_percent, split_amount, split_user, created_at, modified_at
`

type CreateSplitParams struct {
	TransactionID int64           `json:"transaction_id"`
	SplitPercent  decimal.Decimal `json:"split_percent"`
	SplitAmount   decimal.Decimal `json:"split_amount"`
	SplitUser     *int64          `json:"split_user"`
}

func (q *Queries) CreateSplit(ctx context.Context, arg CreateSplitParams) (Split, error) {
	row := q.db.QueryRow(ctx, createSplit,
		arg.TransactionID,
		arg.SplitPercent,
		arg.SplitAmount,
		arg.SplitUser,
	)
	var i Split
	err := row.Scan(
		&i.ID,
		&i.TransactionID,
		&i.TxAmount,
		&i.SplitPercent,
		&i.SplitAmount,
		&i.SplitUser,
		&i.CreatedAt,
		&i.ModifiedAt,
	)
	return i, err
}

const deleteSplit = `-- name: DeleteSplit :one
DELETE FROM "splits" 
WHERE id = $1
RETURNING id, transaction_id, tx_amount, split_percent, split_amount, split_user, created_at, modified_at
`

func (q *Queries) DeleteSplit(ctx context.Context, id int64) (Split, error) {
	row := q.db.QueryRow(ctx, deleteSplit, id)
	var i Split
	err := row.Scan(
		&i.ID,
		&i.TransactionID,
		&i.TxAmount,
		&i.SplitPercent,
		&i.SplitAmount,
		&i.SplitUser,
		&i.CreatedAt,
		&i.ModifiedAt,
	)
	return i, err
}

const deleteTransactionSplits = `-- name: DeleteTransactionSplits :many
DELETE from "splits"
WHERE transaction_id = $1
RETURNING id, transaction_id, tx_amount, split_percent, split_amount, split_user, created_at, modified_at
`

func (q *Queries) DeleteTransactionSplits(ctx context.Context, transactionID int64) ([]Split, error) {
	rows, err := q.db.Query(ctx, deleteTransactionSplits, transactionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Split{}
	for rows.Next() {
		var i Split
		if err := rows.Scan(
			&i.ID,
			&i.TransactionID,
			&i.TxAmount,
			&i.SplitPercent,
			&i.SplitAmount,
			&i.SplitUser,
			&i.CreatedAt,
			&i.ModifiedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSplitByID = `-- name: GetSplitByID :one
SELECT 
    id, transaction_id, tx_amount, split_percent, split_amount, split_user, created_at, modified_at
FROM "splits"
WHERE id = $1 
LIMIT 1
`

func (q *Queries) GetSplitByID(ctx context.Context, id int64) (Split, error) {
	row := q.db.QueryRow(ctx, getSplitByID, id)
	var i Split
	err := row.Scan(
		&i.ID,
		&i.TransactionID,
		&i.TxAmount,
		&i.SplitPercent,
		&i.SplitAmount,
		&i.SplitUser,
		&i.CreatedAt,
		&i.ModifiedAt,
	)
	return i, err
}

const getSplitByIDForUpdate = `-- name: GetSplitByIDForUpdate :one
SELECT 
    id, transaction_id, tx_amount, split_percent, split_amount, split_user, created_at, modified_at
FROM "splits"
WHERE id = $1 
LIMIT 1
FOR UPDATE
`

func (q *Queries) GetSplitByIDForUpdate(ctx context.Context, id int64) (Split, error) {
	row := q.db.QueryRow(ctx, getSplitByIDForUpdate, id)
	var i Split
	err := row.Scan(
		&i.ID,
		&i.TransactionID,
		&i.TxAmount,
		&i.SplitPercent,
		&i.SplitAmount,
		&i.SplitUser,
		&i.CreatedAt,
		&i.ModifiedAt,
	)
	return i, err
}

const getSplitsByTransactionID = `-- name: GetSplitsByTransactionID :many
SELECT
    id, transaction_id, tx_amount, split_percent, split_amount, split_user, created_at, modified_at
FROM "splits"
WHERE transaction_id = $1
ORDER BY created_at desc
`

func (q *Queries) GetSplitsByTransactionID(ctx context.Context, transactionID int64) ([]Split, error) {
	rows, err := q.db.Query(ctx, getSplitsByTransactionID, transactionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Split{}
	for rows.Next() {
		var i Split
		if err := rows.Scan(
			&i.ID,
			&i.TransactionID,
			&i.TxAmount,
			&i.SplitPercent,
			&i.SplitAmount,
			&i.SplitUser,
			&i.CreatedAt,
			&i.ModifiedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSplitsByTransactionIDForUpdate = `-- name: GetSplitsByTransactionIDForUpdate :many
SELECT
    id, transaction_id, tx_amount, split_percent, split_amount, split_user, created_at, modified_at
FROM "splits"
WHERE transaction_id = $1
ORDER BY created_at desc
FOR UPDATE
`

func (q *Queries) GetSplitsByTransactionIDForUpdate(ctx context.Context, transactionID int64) ([]Split, error) {
	rows, err := q.db.Query(ctx, getSplitsByTransactionIDForUpdate, transactionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Split{}
	for rows.Next() {
		var i Split
		if err := rows.Scan(
			&i.ID,
			&i.TransactionID,
			&i.TxAmount,
			&i.SplitPercent,
			&i.SplitAmount,
			&i.SplitUser,
			&i.CreatedAt,
			&i.ModifiedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSplitsByUser = `-- name: GetSplitsByUser :many
SELECT id, transaction_id, tx_amount, split_percent, split_amount, split_user, created_at, modified_at FROM "splits"
WHERE split_user = $1
ORDER BY created_at desc
LIMIT $2
OFFSET $3
FOR UPDATE
`

type GetSplitsByUserParams struct {
	SplitUser *int64 `json:"split_user"`
	Limit     int32  `json:"limit"`
	Offset    int32  `json:"offset"`
}

func (q *Queries) GetSplitsByUser(ctx context.Context, arg GetSplitsByUserParams) ([]Split, error) {
	rows, err := q.db.Query(ctx, getSplitsByUser, arg.SplitUser, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Split{}
	for rows.Next() {
		var i Split
		if err := rows.Scan(
			&i.ID,
			&i.TransactionID,
			&i.TxAmount,
			&i.SplitPercent,
			&i.SplitAmount,
			&i.SplitUser,
			&i.CreatedAt,
			&i.ModifiedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSplitsByUserFiltered = `-- name: GetSplitsByUserFiltered :many
SELECT s.id, s.transaction_id, s.tx_amount, s.split_percent, s.split_amount, s.split_user, s.created_at, s.modified_at FROM "splits" s
INNER JOIN transactions t ON s.transaction_id = t.id
INNER JOIN group_members gm ON t.group_id = gm.group_id
WHERE s.split_user = $1 AND gm.user_id = $2
ORDER BY s.created_at desc
LIMIT $3
OFFSET $4
`

type GetSplitsByUserFilteredParams struct {
	SplitUser *int64 `json:"split_user"`
	UserID    *int64 `json:"user_id"`
	Limit     int32  `json:"limit"`
	Offset    int32  `json:"offset"`
}

func (q *Queries) GetSplitsByUserFiltered(ctx context.Context, arg GetSplitsByUserFilteredParams) ([]Split, error) {
	rows, err := q.db.Query(ctx, getSplitsByUserFiltered,
		arg.SplitUser,
		arg.UserID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Split{}
	for rows.Next() {
		var i Split
		if err := rows.Scan(
			&i.ID,
			&i.TransactionID,
			&i.TxAmount,
			&i.SplitPercent,
			&i.SplitAmount,
			&i.SplitUser,
			&i.CreatedAt,
			&i.ModifiedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSplits = `-- name: ListSplits :many
SELECT 
    id, transaction_id, tx_amount, split_percent, split_amount, split_user, created_at, modified_at 
FROM "splits"
ORDER BY transaction_id, created_at desc
LIMIT $1
OFFSET $2
`

type ListSplitsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListSplits(ctx context.Context, arg ListSplitsParams) ([]Split, error) {
	rows, err := q.db.Query(ctx, listSplits, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Split{}
	for rows.Next() {
		var i Split
		if err := rows.Scan(
			&i.ID,
			&i.TransactionID,
			&i.TxAmount,
			&i.SplitPercent,
			&i.SplitAmount,
			&i.SplitUser,
			&i.CreatedAt,
			&i.ModifiedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSplitsByUserGroups = `-- name: ListSplitsByUserGroups :many
SELECT 
    s.id, s.transaction_id, s.tx_amount, s.split_percent, s.split_amount, s.split_user, s.created_at, s.modified_at 
FROM "splits" s
INNER JOIN transactions t ON s.transaction_id = t.id
INNER JOIN group_members gm ON t.group_id = gm.group_id
WHERE gm.user_id = $1
ORDER BY s.transaction_id, s.created_at desc
LIMIT $2
OFFSET $3
`

type ListSplitsByUserGroupsParams struct {
	UserID *int64 `json:"user_id"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

func (q *Queries) ListSplitsByUserGroups(ctx context.Context, arg ListSplitsByUserGroupsParams) ([]Split, error) {
	rows, err := q.db.Query(ctx, listSplitsByUserGroups, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Split{}
	for rows.Next() {
		var i Split
		if err := rows.Scan(
			&i.ID,
			&i.TransactionID,
			&i.TxAmount,
			&i.SplitPercent,
			&i.SplitAmount,
			&i.SplitUser,
			&i.CreatedAt,
			&i.ModifiedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSplitsForTransaction = `-- name: ListSplitsForTransaction :many
SELECT 
    s.id, s.transaction_id, s.tx_amount, s.split_percent, s.split_amount, s.split_user, s.created_at, s.modified_at
FROM "splits" s
JOIN "transactions" tx ON s.transaction_id = tx.id
WHERE s.transaction_id = $1
`

func (q *Queries) ListSplitsForTransaction(ctx context.Context, transactionID int64) ([]Split, error) {
	rows, err := q.db.Query(ctx, listSplitsForTransaction, transactionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Split{}
	for rows.Next() {
		var i Split
		if err := rows.Scan(
			&i.ID,
			&i.TransactionID,
			&i.TxAmount,
			&i.SplitPercent,
			&i.SplitAmount,
			&i.SplitUser,
			&i.CreatedAt,
			&i.ModifiedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateSplit = `-- name: UpdateSplit :one
UPDATE "splits"
SET split_percent = $2, split_amount = $3, split_user = $4
WHERE id = $1
RETURNING id, transaction_id, tx_amount, split_percent, split_amount, split_user, created_at, modified_at
`

type UpdateSplitParams struct {
	ID           int64           `json:"id"`
	SplitPercent decimal.Decimal `json:"split_percent"`
	SplitAmount  decimal.Decimal `json:"split_amount"`
	SplitUser    *int64          `json:"split_user"`
}

func (q *Queries) UpdateSplit(ctx context.Context, arg UpdateSplitParams) (Split, error) {
	row := q.db.QueryRow(ctx, updateSplit,
		arg.ID,
		arg.SplitPercent,
		arg.SplitAmount,
		arg.SplitUser,
	)
	var i Split
	err := row.Scan(
		&i.ID,
		&i.TransactionID,
		&i.TxAmount,
		&i.SplitPercent,
		&i.SplitAmount,
		&i.SplitUser,
		&i.CreatedAt,
		&i.ModifiedAt,
	)
	return i, err
}
